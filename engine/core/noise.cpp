#include <numeric>
#include <algorithm>
#include <cmath>
#include <random>
#include "core/logger.h"
#include "core/noise.h"
#include "core/mathlib.h"

namespace cyb::noise2
{
    // primes for hashing
    static constexpr int primeX = 501125321;
    static constexpr int primeY = 1136930381;

    // Generated by gen_perlin_gradients.py
    static const float perlinGradients2D[] = {
        1.0000000f, 0.0000000f, 0.9951847f, 0.0980171f, 0.9807853f, 0.1950903f, 0.9569403f, 0.2902847f,
        0.9238795f, 0.3826834f, 0.8819213f, 0.4713967f, 0.8314696f, 0.5555702f, 0.7730105f, 0.6343933f,
        0.7071068f, 0.7071068f, 0.6343933f, 0.7730105f, 0.5555702f, 0.8314696f, 0.4713967f, 0.8819213f,
        0.3826834f, 0.9238795f, 0.2902847f, 0.9569403f, 0.1950903f, 0.9807853f, 0.0980171f, 0.9951847f,
        0.0000000f, 1.0000000f, -0.0980171f, 0.9951847f, -0.1950903f, 0.9807853f, -0.2902847f, 0.9569403f,
        -0.3826834f, 0.9238795f, -0.4713967f, 0.8819213f, -0.5555702f, 0.8314696f, -0.6343933f, 0.7730105f,
        -0.7071068f, 0.7071068f, -0.7730105f, 0.6343933f, -0.8314696f, 0.5555702f, -0.8819213f, 0.4713967f,
        -0.9238795f, 0.3826834f, -0.9569403f, 0.2902847f, -0.9807853f, 0.1950903f, -0.9951847f, 0.0980171f,
        -1.0000000f, 0.0000000f, -0.9951847f, -0.0980171f, -0.9807853f, -0.1950903f, -0.9569403f, -0.2902847f,
        -0.9238795f, -0.3826834f, -0.8819213f, -0.4713967f, -0.8314696f, -0.5555702f, -0.7730105f, -0.6343933f,
        -0.7071068f, -0.7071068f, -0.6343933f, -0.7730105f, -0.5555702f, -0.8314696f, -0.4713967f, -0.8819213f,
        -0.3826834f, -0.9238795f, -0.2902847f, -0.9569403f, -0.1950903f, -0.9807853f, -0.0980171f, -0.9951847f,
        -0.0000000f, -1.0000000f, 0.0980171f, -0.9951847f, 0.1950903f, -0.9807853f, 0.2902847f, -0.9569403f,
        0.3826834f, -0.9238795f, 0.4713967f, -0.8819213f, 0.5555702f, -0.8314696f, 0.6343933f, -0.7730105f,
        0.7071068f, -0.7071068f, 0.7730105f, -0.6343933f, 0.8314696f, -0.5555702f, 0.8819213f, -0.4713967f,
        0.9238795f, -0.3826834f, 0.9569403f, -0.2902847f, 0.9807853f, -0.1950903f, 0.9951847f, -0.0980171f
    };
 
    // Generated by gen_perlin_gradients.py
    static constexpr float worleyRandomVecs2D[] = {
        -0.2143506f, 0.4415321f, 0.6510294f, -0.1978107f, -0.1001892f, -0.1178838f, -0.3755103f, 0.3018274f,
        -0.8529928f, -0.7842539f, -0.0919420f, -0.1314491f, -0.3180378f, 0.8152802f, 0.4145662f, -0.4578725f,
        0.0065746f, 0.5169441f, 0.8174434f, 0.4858670f, 0.1683566f, -0.5013704f, -0.1837406f, -0.5332742f,
        -0.2097284f, 0.0168382f, 0.9176231f, 0.1303826f, 0.4799096f, 0.3804742f, 0.9408944f, 0.1058209f,
        -0.4194404f, -0.7770421f, -0.6292400f, -0.3480286f, 0.3293919f, -0.3864398f, -0.0269778f, 0.6762571f,
        -0.5015928f, -0.9873967f, 0.2477123f, -0.6368469f, -0.8912868f, -0.2434983f, 0.0739764f, -0.6195096f,
        0.3658279f, 0.2288376f, -0.1153040f, 0.1811176f, 0.8493514f, -0.2917698f, 0.4702567f, -0.1884250f,
        0.1950662f, 0.4019734f, -0.6487913f, 0.4725412f, -0.0108053f, -0.2026005f, -0.5825363f, -0.9372767f,
        0.5438889f, -0.7536195f, 0.2639481f, -0.6779040f, 0.6757871f, -0.0338373f, 0.7513847f, 0.4596258f,
        0.3433386f, -0.4587607f, 0.5172687f, 0.6282103f, 0.7325347f, -0.0432574f, -0.8338639f, -0.3323464f,
        -0.2705509f, 0.8072256f, 0.7286570f, 0.8150706f, -0.9782979f, -0.5102092f, -0.1184807f, -0.1288073f,
        0.5319356f, -0.7751918f, -0.9473439f, -0.1442928f, -0.3924917f, 0.6240442f, -0.9686623f, 0.7393381f,
        -0.2439338f, 0.1023275f, 0.2947618f, -0.7182543f, -0.3042337f, -0.5544600f, -0.3845568f, -0.2871484f,
        0.0682042f, -0.9572871f, -0.9553869f, 0.2048328f, 0.5208389f, -0.8757180f, -0.2892230f, 0.9715723f,
        -0.4253943f, 0.0652732f, -0.6572654f, 0.9744352f, 0.0936213f, 0.3465997f, -0.2037805f, 0.2985088f,
        0.8370765f, 0.5843119f, 0.4793635f, -0.5535017f, -0.7798188f, 0.4877721f, -0.8145101f, 0.7899759f,
        -0.2289601f, 0.5266386f, 0.2328015f, -0.6544656f, 0.4380332f, -0.1545290f, 0.9541115f, -0.3581549f,
        -0.5495563f, 0.4759228f, -0.8339480f, 0.1960707f, 0.9422832f, -0.3082551f, 0.9078600f, -0.3700014f,
        0.0324569f, 0.2362442f, 0.9365328f, -0.5488289f, 0.9305124f, -0.8776852f, 0.8856568f, 0.0780721f,
        -0.4257333f, -0.4887829f, -0.5809553f, 0.7349069f, -0.9508807f, -0.0542190f, -0.3504669f, 0.0239572f,
        0.3590217f, -0.4658166f, -0.0887248f, 0.5130257f, -0.1749682f, -0.7081454f, 0.9265277f, 0.4919947f,
        -0.8878433f, 0.5783800f, -0.6295862f, -0.8539861f, 0.1359280f, 0.3036155f, 0.3804280f, -0.6067012f,
        -0.7470301f, -0.9086912f, -0.5689766f, 0.8520460f, 0.4886749f, 0.6960476f, 0.4162524f, -0.6012149f,
        -0.0053220f, 0.2620568f, -0.2063755f, -0.0528102f, -0.4872948f, 0.0753261f, 0.9819987f, 0.3374845f,
        -0.8743977f, -0.7875462f, -0.3374189f, -0.9414403f, -0.4205556f, -0.5115547f, 0.0745092f, 0.2580475f,
        -0.4645322f, -0.0263537f, 0.2924232f, -0.4973075f, 0.4007050f, 0.8749321f, 0.8855313f, -0.7255471f,
        -0.2282338f, 0.8864015f, -0.1073000f, -0.4199036f, 0.8700631f, -0.7592356f, 0.9276631f, -0.5831199f,
        -0.4634695f, -0.9875048f, -0.9471387f, -0.0740155f, -0.1829833f, 0.3740542f, -0.7217681f, -0.0033289f,
        -0.2820464f, 0.7648473f, -0.6548793f, 0.6844199f, 0.4631831f, 0.6615904f, 0.7041429f, -0.0282137f,
        -0.4240007f, 0.0823086f, -0.2170668f, 0.0742540f, -0.1495828f, 0.4207138f, 0.8265537f, -0.3540101f,
        0.0963314f, -0.6875465f, 0.2718212f, 0.8433171f, -0.6600350f, -0.2489159f, -0.5791291f, 0.6100578f,
        -0.5543922f, 0.2041282f, 0.5267381f, -0.1001959f, 0.4905146f, -0.9046398f, -0.4556226f, 0.6834540f,
        0.8539141f, -0.3181426f, -0.0303235f, -0.9512502f, 0.5909521f, 0.7051457f, 0.9688121f, 0.3046122f,
        0.3254844f, 0.0559621f, -0.4997710f, -0.0442594f, 0.7513286f, 0.9684779f, 0.6423232f, -0.6540056f,
        0.9819619f, 0.8247795f, -0.2967079f, -0.4474496f, -0.6127765f, 0.5276400f, -0.2678876f, 0.8786995f,
        0.8527635f, 0.3839347f, 0.6958034f, -0.8634591f, 0.6643329f, -0.0895876f, -0.2002279f, 0.0977528f,
        0.6428701f, -0.3704695f, -0.6219453f, 0.9038158f, -0.5479947f, -0.7062981f, 0.8367490f, 0.8172824f,
        0.2584832f, 0.0263006f, -0.1051908f, 0.0362692f, 0.1750430f, 0.3072194f, -0.1348843f, -0.6561827f,
        0.1629166f, 0.5402217f, -0.3887977f, 0.0790314f, 0.9073313f, 0.7361855f, -0.3827230f, 0.7259080f,
        -0.7995771f, 0.6057015f, -0.6568311f, 0.1162157f, 0.3915297f, 0.1591951f, 0.6559846f, -0.2947629f,
        -0.2942644f, -0.4209927f, -0.5823938f, -0.5574651f, 0.0932967f, 0.2971152f, -0.0697125f, -0.0714600f,
        0.0429165f, 0.6942647f, 0.9749786f, -0.4432684f, -0.9103700f, -0.9483122f, -0.7090470f, 0.2965806f,
        -0.4764397f, -0.1105558f, -0.7431132f, -0.8464950f, 0.2879866f, 0.3381160f, -0.0184348f, -0.8061163f,
        0.7412368f, -0.9860157f, 0.7931287f, 0.3362128f, 0.8082897f, 0.4398563f, 0.4574441f, 0.5639708f,
        -0.1462599f, 0.5261986f, 0.4616282f, 0.2381835f, -0.7053659f, 0.7377168f, 0.4276007f, -0.9215289f,
        -0.8204699f, -0.9440634f, -0.0189176f, 0.6776360f, -0.4700607f, -0.9488793f, -0.1207978f, 0.8877746f,
        0.3321830f, 0.8882459f, 0.9042106f, -0.4519439f, 0.8096264f, 0.0341331f, -0.1328109f, -0.3370703f,
        -0.9404792f, 0.5733821f, -0.5801742f, -0.4740781f, 0.1132183f, 0.5479527f, -0.4773667f, -0.8857630f,
        0.7775512f, 0.3903683f, -0.3052454f, -0.6075144f, -0.5810282f, -0.9635039f, -0.2383540f, -0.6195747f,
        -0.0196203f, -0.3704849f, 0.3471157f, 0.3195013f, -0.9515835f, -0.9679211f, 0.9660750f, 0.0103929f,
        0.6601947f, 0.1558757f, 0.4763066f, -0.6260684f, 0.0645270f, 0.3980831f, -0.2942235f, 0.7676676f,
        0.6858680f, 0.5118215f, -0.3353951f, 0.5901446f, -0.4448655f, 0.7851636f, 0.7612469f, -0.3636125f,
        0.0120096f, 0.9487353f, 0.8116892f, -0.5196733f, -0.8038388f, 0.4243276f, -0.5050782f, -0.6953900f,
        -0.1951833f, -0.7061657f, -0.2667093f, -0.7290769f, -0.9559859f, 0.8965363f, -0.5083939f, -0.9183834f,
        -0.6290346f, 0.1278344f, 0.7045263f, 0.7643427f, -0.9188182f, -0.4362337f, -0.0986286f, -0.6594185f,
        -0.7851928f, -0.6792313f, -0.1857256f, 0.5284095f, -0.3760889f, 0.4987835f, -0.6749012f, 0.0564251f,
        -0.9929421f, -0.3707286f, -0.8589150f, 0.5095037f, -0.6634409f, 0.5407608f, 0.0434019f, -0.4842407f,
        0.8799212f, -0.1514805f, 0.9504383f, 0.4629382f, 0.0854447f, -0.7512156f, -0.1328518f, -0.4994739f,
        -0.9347220f, 0.4081504f, 0.6017097f, -0.6512674f, -0.0476455f, -0.2257102f, -0.5367548f, -0.4102643f,
        -0.5809558f, -0.8054162f, -0.4526999f, -0.2519418f, -0.5764931f, 0.2182210f, -0.9825156f, 0.2899031f,
        -0.6232083f, -0.3759745f, -0.3069432f, 0.6570014f, 0.9580157f, -0.3681692f, -0.4487506f, -0.6724623f,
        -0.5326691f, 0.3473914f, 0.8683837f, -0.9254197f, -0.4025867f, 0.3456102f, 0.5997301f, -0.9072468f,
        -0.1688556f, 0.1007761f, 0.0124998f, 0.6847335f, -0.6027489f, -0.9081504f, -0.0157681f, -0.3441329f,
        0.3166472f, -0.9779973f, 0.1610355f, -0.9134977f, 0.9855230f, 0.7172790f, 0.2435614f, -0.2977292f
    };

    [[nodiscard]] static float MakeInt32Range(float n)
    {
        constexpr float limit = 1073741824.0f; // 2^30

        if (n >= limit)
            return n - 2.0f * limit * std::floor((n + limit) / (2.0f * limit));
        if (n <= -limit)
            return n - 2.0f * limit * std::floor((n - limit) / (2.0f * limit));

        return n;
    }

    [[nodiscard]] static inline int Hash(int seed, int xPrimed, int yPrimed)
    {
        int hash = seed ^ xPrimed ^ yPrimed;
        hash *= 0x27d4eb2d;
        return hash;
    }

    [[nodiscard]] static inline float GradCoord(int seed, int x, int y, float xd, float yd)
    {
        int hash = Hash(seed, x, y);
        hash ^= hash >> 15;
        int index = (hash & 0x3f) << 1;
        return xd * perlinGradients2D[index] + yd * perlinGradients2D[index + 1];
    }

    float PerlinNoise2D(int seed, float x, float y)
    {
        const int x0 = static_cast<int>(std::floor(x)) * primeX;
        const int y0 = static_cast<int>(std::floor(y)) * primeY;
        const int x1 = x0 + primeX;
        const int y1 = y0 + primeY;

        const float xd0 = x - std::floor(x);
        const float yd0 = y - std::floor(y);
        const float xd1 = xd0 - 1.0;
        const float yd1 = yd0 - 1.0;

        const float xs = QuinticSmoothStep(xd0);
        const float ys = QuinticSmoothStep(yd0);

        const float n00 = GradCoord(seed, x0, y0, xd0, yd0);
        const float n10 = GradCoord(seed, x1, y0, xd1, yd0);
        const float n01 = GradCoord(seed, x0, y1, xd0, yd1);
        const float n11 = GradCoord(seed, x1, y1, xd1, yd1);

        const float xf0 = Lerp(n00, n10, xs);
        const float xf1 = Lerp(n01, n11, xs);
        const float result = Lerp(xf0, xf1, ys);

        // Try to map the result to [0..1] range.
        return (1.0 + result * 1.6409504127933312f) * 0.5f;
    }

    float PerlinNoise2D_FBM(const PerlinNoiseParams& param, float x, float y)
    {
        float value = 0.0;
        float amplitude = 1.0;
        float amplitudeSum = 0.0;
        float frequency = param.frequency;

        for (uint32_t i = 0; i < param.octaves; i++)
        {
            const float signal = PerlinNoise2D(
                (param.seed + i) & 0xffffffff,
                MakeInt32Range(x * frequency),
                MakeInt32Range(y * frequency));
            value += signal * amplitude;
            amplitudeSum += amplitude;
            amplitude *= param.persistence;
            frequency *= param.lacunarity;
        }

        const float fractalBounding = 1.0f / std::sqrt(amplitudeSum);
        return value * fractalBounding;
    }

    float CellularNoise2D(uint32_t seed, float jitterModifier, float x, float y)
    {
        const int xr = static_cast<int>(std::lround(x));
        const int yr = static_cast<int>(std::lround(y));

        float distance0 = std::numeric_limits<float>::max();
        //double distance1 = std::numeric_limits<double>::max();
        int closestHash = 0;

        const float cellularJitter = 0.43701595f * jitterModifier;

        int xPrimed = (xr - 1) * primeX;
        const int yPrimedBase = (yr - 1) * primeY;

        for (int xi = xr - 1; xi <= xr + 1; xi++)
        {
            int yPrimed = yPrimedBase;

            for (int yi = yr - 1; yi <= yr + 1; yi++)
            {
                const int hash = Hash(seed, xPrimed, yPrimed);
                const int idx = hash & (255 << 1);

                const float vecX = (float)(xi - x) + worleyRandomVecs2D[idx] * cellularJitter;
                const float vecY = (float)(yi - y) + worleyRandomVecs2D[idx | 1] * cellularJitter;
                const float newDistance = vecX * vecX + vecY * vecY;

                //distance1 = std::max(std::min(distance1, newDistance), distance0);
                if (newDistance < distance0)
                {
                    distance0 = newDistance;
                    closestHash = hash;
                }

                yPrimed += primeY;
            }

            xPrimed += primeX;
        }

        // try to map the output to a [0..1] range
        return (distance0 * 1.15);
    }

    float CellularNoise2D_FBM(const CellularNoiseParams& param, float x, float y)
    {
        float value = 0.0;
        float amplitude = 1.0;
        float frequency = param.frequency;

        for (uint32_t i = 0; i < param.octaves; i++)
        {
            const float signal = CellularNoise2D(
                (param.seed + i) & 0xffffffff,
                param.jitterModifier,
                MakeInt32Range(x * frequency),
                MakeInt32Range(y * frequency));
            
            value += signal * amplitude;
            amplitude *= param.persistence;
            frequency *= param.lacunarity;
        }

        return value;
    }

    NoiseImage::NoiseImage(const NoiseImageDimensions& size) :
        m_size(size)
    {
        m_stride = sizeof(Color) * m_size.width;
        m_image = std::make_unique<Color[]>(m_size.width * m_size.height);
    }

    NoiseImage::Color* NoiseImage::GetPtr(uint32_t row)
    {
        return GetPtr(0, row);
    }

    NoiseImage::Color* NoiseImage::GetPtr(uint32_t x, uint32_t y)
    {
        return &(m_image.get()[y * m_size.width + x]);
    }

    const NoiseImage::Color* NoiseImage::GetConstPtr(uint32_t row) const
    {
        return GetConstPtr(0, row);
    }

    const NoiseImage::Color* NoiseImage::GetConstPtr(uint32_t x, uint32_t y) const
    {
        return &(m_image.get()[y * m_size.width + x]);
    }

    size_t NoiseImage::GetMemoryUsage() const
    {
        return m_stride * m_size.height;
    }

    void RenderNoiseImageRows(
        NoiseImage& image,
        const NoiseImageDesc* desc,
        uint32_t rowStart, uint32_t rowCount)
    {
        assert(rowCount > 0);
        assert((rowStart + rowCount) <= image.GetHeight());
        
        auto mapToColor = [] (float value) -> NoiseImage::Color {
            uint8_t color = static_cast<uint8_t>(std::clamp(255.0 * value, 0.0, 255.0));
            return NoiseImage::Color{ color, color, color, 0xff };
        };

        for (uint32_t y = rowStart; y < rowStart + rowCount; ++y)
        {
            NoiseImage::Color* dest = image.GetPtr(y);
            for (uint32_t x = 0; x < desc->size.width; ++x)
            {
                const float value = (double)desc->GetValue(
                    float(x + desc->offset.x) * desc->freqScale * 0.002f,
                    float(y + desc->offset.y) * desc->freqScale * 0.002f);
                dest[x] = mapToColor(value);
            }
        }
    }

    std::shared_ptr<NoiseImage> RenderNoiseImage(const NoiseImageDesc& desc)
    {
        assert(desc.size.width > 0);
        assert(desc.size.height > 0);

        auto image = std::make_shared<NoiseImage>(desc.size);
        RenderNoiseImageRows(*image.get(), &desc, 0, image->GetHeight());
        return image;
    }
} // namespace cyb::noise2